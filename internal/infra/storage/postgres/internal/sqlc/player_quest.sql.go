// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: player_quest.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getPlayerQuest = `-- name: GetPlayerQuest :one

SELECT started_at, updated_at, id, player_id, quest_id, completed_at
FROM "player_quests" pq
WHERE pq."player_id" = $1 AND pq."quest_id" = $2
`

type GetPlayerQuestParams struct {
	PlayerID string
	QuestID  uuid.UUID
}

// ---------------------
// Get Player Quests --
// ---------------------
func (q *Queries) GetPlayerQuest(ctx context.Context, arg GetPlayerQuestParams) (PlayerQuest, error) {
	row := q.db.QueryRow(ctx, getPlayerQuest, arg.PlayerID, arg.QuestID)
	var i PlayerQuest
	err := row.Scan(
		&i.StartedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.PlayerID,
		&i.QuestID,
		&i.CompletedAt,
	)
	return i, err
}

const getPlayerQuestTasks = `-- name: GetPlayerQuestTasks :many
SELECT pqt.started_at, pqt.updated_at, pqt.id, pqt.player_id, pqt.player_quest_id, pqt.task_id, pqt.completed_at, t.created_at, t.updated_at, t.deleted_at, t.quest_id, t.id, t.name, t.description, t.required_for_completion, t.rule, t.depends_on
FROM "player_quest_tasks" pqt
JOIN "tasks_with_its_dependencies" t ON t."id" = pqt."task_id"
WHERE pqt."player_id" = $1 AND t."quest_id" = $2
`

type GetPlayerQuestTasksParams struct {
	PlayerID string
	QuestID  uuid.UUID
}

type GetPlayerQuestTasksRow struct {
	StartedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	ID                     uuid.UUID
	PlayerID               string
	PlayerQuestID          uuid.UUID
	TaskID                 uuid.UUID
	CompletedAt            pgtype.Timestamptz
	TasksWithItsDependency TasksWithItsDependency
}

func (q *Queries) GetPlayerQuestTasks(ctx context.Context, arg GetPlayerQuestTasksParams) ([]GetPlayerQuestTasksRow, error) {
	rows, err := q.db.Query(ctx, getPlayerQuestTasks, arg.PlayerID, arg.QuestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerQuestTasksRow
	for rows.Next() {
		var i GetPlayerQuestTasksRow
		if err := rows.Scan(
			&i.StartedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.PlayerID,
			&i.PlayerQuestID,
			&i.TaskID,
			&i.CompletedAt,
			&i.TasksWithItsDependency.CreatedAt,
			&i.TasksWithItsDependency.UpdatedAt,
			&i.TasksWithItsDependency.DeletedAt,
			&i.TasksWithItsDependency.QuestID,
			&i.TasksWithItsDependency.ID,
			&i.TasksWithItsDependency.Name,
			&i.TasksWithItsDependency.Description,
			&i.TasksWithItsDependency.RequiredForCompletion,
			&i.TasksWithItsDependency.Rule,
			&i.TasksWithItsDependency.DependsOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPlayerQuestAsCompleted = `-- name: MarkPlayerQuestAsCompleted :exec
WITH "completion_list" AS (
	SELECT (pqt."completed_at" IS NOT NULL) AS "completed"
	FROM "tasks" t
	LEFT JOIN "player_quest_tasks" pqt ON t.id = pqt."task_id" AND pqt."player_id" = $2
	WHERE t."quest_id" = $1
)
UPDATE "player_quests"
SET "completed_at" = NOW()
WHERE 
	"player_quests"."player_id" = $2 AND
	"player_quests"."quest_id" = $1 AND 
	TRUE = ALL((SELECT "completed" FROM "completion_list"))
`

type MarkPlayerQuestAsCompletedParams struct {
	QuestID  uuid.UUID
	PlayerID string
}

func (q *Queries) MarkPlayerQuestAsCompleted(ctx context.Context, arg MarkPlayerQuestAsCompletedParams) error {
	_, err := q.db.Exec(ctx, markPlayerQuestAsCompleted, arg.QuestID, arg.PlayerID)
	return err
}

const markPlayerQuestTasksAsCompleted = `-- name: MarkPlayerQuestTasksAsCompleted :exec

UPDATE "player_quest_tasks"
SET "completed_at" = NOW()
WHERE "player_id" = $1 AND "task_id" IN ($2)
`

type MarkPlayerQuestTasksAsCompletedParams struct {
	PlayerID       string
	TasksCompleted []uuid.UUID
}

// -------------------------------------
// Mark Quest And Tasks As Completed --
// -------------------------------------
func (q *Queries) MarkPlayerQuestTasksAsCompleted(ctx context.Context, arg MarkPlayerQuestTasksAsCompletedParams) error {
	_, err := q.db.Exec(ctx, markPlayerQuestTasksAsCompleted, arg.PlayerID, arg.TasksCompleted)
	return err
}

const startPlayerQuest = `-- name: StartPlayerQuest :one

INSERT INTO "player_quests" ("player_id", "quest_id")
SELECT $1, q."id"
FROM "quests" q
WHERE q."id" = $2 AND q."deleted_at" IS NULL
RETURNING started_at, updated_at, id, player_id, quest_id, completed_at
`

type StartPlayerQuestParams struct {
	PlayerID string
	QuestID  uuid.UUID
}

// ----------------------
// Start Player Quest --
// ----------------------
func (q *Queries) StartPlayerQuest(ctx context.Context, arg StartPlayerQuestParams) (PlayerQuest, error) {
	row := q.db.QueryRow(ctx, startPlayerQuest, arg.PlayerID, arg.QuestID)
	var i PlayerQuest
	err := row.Scan(
		&i.StartedAt,
		&i.UpdatedAt,
		&i.ID,
		&i.PlayerID,
		&i.QuestID,
		&i.CompletedAt,
	)
	return i, err
}

const startPlayerTasksForQuest = `-- name: StartPlayerTasksForQuest :many
WITH "player_quest_tasks_created" AS (
    INSERT INTO "player_quest_tasks" ("player_id", "player_quest_id", "task_id")
    SELECT pq."player_id", $1, t."id"
    FROM "player_quests" pq
    JOIN "tasks_with_its_dependencies" t ON t."quest_id" = pq."quest_id"
    WHERE pq."id" = $1 AND ARRAY_LENGTH(t."depends_on", 1) IS NULL
    RETURNING started_at, updated_at, id, player_id, player_quest_id, task_id, completed_at
)
SELECT pqt.started_at, pqt.updated_at, pqt.id, pqt.player_id, pqt.player_quest_id, pqt.task_id, pqt.completed_at, twd.created_at, twd.updated_at, twd.deleted_at, twd.quest_id, twd.id, twd.name, twd.description, twd.required_for_completion, twd.rule, twd.depends_on
FROM "player_quest_tasks_created" pqt
JOIN "tasks_with_its_dependencies" twd ON twd."id" = pqt."task_id"
`

type StartPlayerTasksForQuestRow struct {
	StartedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	ID                     uuid.UUID
	PlayerID               string
	PlayerQuestID          uuid.UUID
	TaskID                 uuid.UUID
	CompletedAt            pgtype.Timestamptz
	TasksWithItsDependency TasksWithItsDependency
}

func (q *Queries) StartPlayerTasksForQuest(ctx context.Context, playerQuestID uuid.UUID) ([]StartPlayerTasksForQuestRow, error) {
	rows, err := q.db.Query(ctx, startPlayerTasksForQuest, playerQuestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StartPlayerTasksForQuestRow
	for rows.Next() {
		var i StartPlayerTasksForQuestRow
		if err := rows.Scan(
			&i.StartedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.PlayerID,
			&i.PlayerQuestID,
			&i.TaskID,
			&i.CompletedAt,
			&i.TasksWithItsDependency.CreatedAt,
			&i.TasksWithItsDependency.UpdatedAt,
			&i.TasksWithItsDependency.DeletedAt,
			&i.TasksWithItsDependency.QuestID,
			&i.TasksWithItsDependency.ID,
			&i.TasksWithItsDependency.Name,
			&i.TasksWithItsDependency.Description,
			&i.TasksWithItsDependency.RequiredForCompletion,
			&i.TasksWithItsDependency.Rule,
			&i.TasksWithItsDependency.DependsOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startPlayerTasksThatHadTheDependenciesCompleted = `-- name: StartPlayerTasksThatHadTheDependenciesCompleted :exec
WITH "pq_tasks_status" AS (
    SELECT pqt."task_id", (pqt."completed_at" IS NOT NULL) AS "completed"
    FROM "player_quests" pq
    JOIN "player_quest_tasks" pqt ON pqt."player_quest_id" = pq."id"
    WHERE pq."quest_id" = $1 AND pq."player_id" = $2
), "pq_pending_tasks" AS (
	SELECT t."id"
	FROM "tasks" t
	WHERE
	    t."quest_id" = $1 AND
	    t."id" NOT IN (SELECT "task_id" FROM "pq_tasks_status")
), "pq_tasks_ready_to_start" AS (
    SELECT td."this_task" AS "id"
    FROM "tasks_dependencies" td
    WHERE td."this_task" IN (SELECT "id" FROM "pq_pending_tasks")
    GROUP BY td."this_task"
    HAVING ARRAY_AGG(td."depends_on_task") <@ ARRAY_AGG((SELECT "task_id" FROM "pq_tasks_status" WHERE "completed" = TRUE))
)
INSERT INTO "player_quest_tasks" ("player_id", "player_quest_id", "task_id")
SELECT $2, pq2."id", trs."id"
FROM "pq_tasks_ready_to_start" trs
CROSS JOIN "player_quests" pq2
WHERE pq2."quest_id" = $1 AND pq2."player_id" = $2
`

type StartPlayerTasksThatHadTheDependenciesCompletedParams struct {
	QuestID  uuid.UUID
	PlayerID string
}

func (q *Queries) StartPlayerTasksThatHadTheDependenciesCompleted(ctx context.Context, arg StartPlayerTasksThatHadTheDependenciesCompletedParams) error {
	_, err := q.db.Exec(ctx, startPlayerTasksThatHadTheDependenciesCompleted, arg.QuestID, arg.PlayerID)
	return err
}

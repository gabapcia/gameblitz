// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: player_quest_task.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getPlayerQuestTasks = `-- name: GetPlayerQuestTasks :many
SELECT pqt.started_at, pqt.updated_at, pqt.id, pqt.player_id, pqt.task_id, pqt.completed_at, t.created_at, t.updated_at, t.deleted_at, t.quest_id, t.id, t.name, t.description, t.required_for_completion, t.rule, ARRAY_AGG(ptd."depends_on_task")::UUID[] AS "depends_on"
FROM "player_quest_tasks" pqt
JOIN "tasks" t ON t."id" = pqt."task_id"
LEFT JOIN "tasks_dependencies" ptd ON t."id" = ptd."this_task"
WHERE pqt."player_id" = $1 AND t."quest_id" = $2
GROUP BY pqt."task_id"
`

type GetPlayerQuestTasksParams struct {
	PlayerID string
	QuestID  uuid.UUID
}

type GetPlayerQuestTasksRow struct {
	StartedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	ID          uuid.UUID
	PlayerID    string
	TaskID      uuid.UUID
	CompletedAt pgtype.Timestamptz
	Task        Task
	DependsOn   []uuid.UUID
}

func (q *Queries) GetPlayerQuestTasks(ctx context.Context, arg GetPlayerQuestTasksParams) ([]GetPlayerQuestTasksRow, error) {
	rows, err := q.db.Query(ctx, getPlayerQuestTasks, arg.PlayerID, arg.QuestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerQuestTasksRow
	for rows.Next() {
		var i GetPlayerQuestTasksRow
		if err := rows.Scan(
			&i.StartedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.PlayerID,
			&i.TaskID,
			&i.CompletedAt,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.DeletedAt,
			&i.Task.QuestID,
			&i.Task.ID,
			&i.Task.Name,
			&i.Task.Description,
			&i.Task.RequiredForCompletion,
			&i.Task.Rule,
			&i.DependsOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startPlayerTasksForQuest = `-- name: StartPlayerTasksForQuest :many
WITH "player_quest_tasks_created" AS (
    INSERT INTO "player_quest_tasks" ("player_id", "task_id")
    SELECT $1, t."id"
    FROM "tasks" t
    WHERE t."quest_id" = $2 AND t."depends_on" IS NULL
    RETURNING started_at, updated_at, id, player_id, task_id, completed_at
)
SELECT pqt.started_at, pqt.updated_at, pqt.id, pqt.player_id, pqt.task_id, pqt.completed_at, t.created_at, t.updated_at, t.deleted_at, t.quest_id, t.id, t.name, t.description, t.required_for_completion, t.rule, ARRAY_AGG(ptd."depends_on_task")::UUID[] AS "depends_on"
FROM "player_quest_tasks_created" pqt
JOIN "tasks" t ON t."id" = pqt."task_id"
LEFT JOIN "tasks_dependencies" ptd ON t."id" = ptd."this_task"
GROUP BY pqt."task_id"
`

type StartPlayerTasksForQuestParams struct {
	PlayerID string
	QuestID  uuid.UUID
}

type StartPlayerTasksForQuestRow struct {
	StartedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	ID          uuid.UUID
	PlayerID    string
	TaskID      uuid.UUID
	CompletedAt pgtype.Timestamptz
	Task        Task
	DependsOn   []uuid.UUID
}

func (q *Queries) StartPlayerTasksForQuest(ctx context.Context, arg StartPlayerTasksForQuestParams) ([]StartPlayerTasksForQuestRow, error) {
	rows, err := q.db.Query(ctx, startPlayerTasksForQuest, arg.PlayerID, arg.QuestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StartPlayerTasksForQuestRow
	for rows.Next() {
		var i StartPlayerTasksForQuestRow
		if err := rows.Scan(
			&i.StartedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.PlayerID,
			&i.TaskID,
			&i.CompletedAt,
			&i.Task.CreatedAt,
			&i.Task.UpdatedAt,
			&i.Task.DeletedAt,
			&i.Task.QuestID,
			&i.Task.ID,
			&i.Task.Name,
			&i.Task.Description,
			&i.Task.RequiredForCompletion,
			&i.Task.Rule,
			&i.DependsOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
